{"version":3,"file":"static/js/443.8b56372b.chunk.js","mappings":"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","sources":["algorithms/Push-Relabel.ts","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js"],"sourcesContent":["import {\r\n  Graph,\r\n  GraphMutation,\r\n  Node,\r\n  Edge,\r\n  GraphEdgeFlowMutation,\r\n  GraphNodeHighlightMutation,\r\n  GraphEdgeHighlightMutation,\r\n  GraphNodeHeightMutation,\r\n  GraphNodeExcessMutation,\r\n  GraphCombinedMutation\r\n} from \"../CytoscapeGraph\";\r\nimport { Algorithm } from \"../algorithm\";\r\n\r\n/** The Push-Relabel algorithm */\r\nconst PushRelabel: Algorithm = {\r\n  name: \"Push-Relabel\",\r\n  linearDataStructure: \"none\",\r\n  pseudocode: ({ sourceName, sinkName }) => String.raw`\r\n    \\begin{algorithm}\r\n    \\begin{algorithmic}\r\n    \\PROCEDURE{Push-Relabel}{$G=(V,\\ E),\\ ${sourceName} \\in V,\\ ${sinkName} \\in V$}\r\n        \\FOR{vertex $v$}\r\n          \\STATE $v.h = 0$\r\n          \\STATE $v.e = 0$\r\n        \\ENDFOR\r\n\r\n        \\STATE $s.h = \\left|V\\right|$\r\n\r\n        \\FOR{vertex $v$ adjacent to $${sourceName}$}\r\n          \\STATE $(${sourceName}, v).f = (${sourceName}, v).c$\r\n          \\STATE $v.e = (${sourceName}, v).c$\r\n          \\STATE $${sourceName}.e = ${sourceName}.e - (${sourceName}, v).c$\r\n        \\ENDFOR\r\n\r\n        \\WHILE{there exists an applicable push or relabel operation}\r\n            \\STATE select an applicable push or relabel operation and perform it\r\n        \\ENDWHILE\r\n\r\n        \\RETURN $t.e$\r\n    \\ENDPROCEDURE\r\n    \\STATE\r\n    \\PROCEDURE{Push}{$u, v$}\r\n        \\STATE $\\Delta f = \\min(u.e, (u, v).c - (u, v).f)$\r\n        \\STATE $(u, v).f = (u, v).f + \\Delta f$\r\n        \\STATE $(v, u).f = (v, u).f - \\Delta f$\r\n        \\STATE $u.e = u.e - \\Delta f$\r\n        \\STATE $v.e = v.e + \\Delta f$\r\n    \\ENDPROCEDURE\r\n    \\STATE\r\n    \\PROCEDURE{Relabel}{$u$}\r\n        \\STATE $u.h = 1 + \\min\\{ v.h \\colon (u, v).c > (u, v).f \\}$\r\n    \\ENDPROCEDURE\r\n    \\end{algorithmic}\r\n    \\end{algorithm}\r\n  `,\r\n  references: [\r\n    {\r\n      label: `Push-Relabel Algorithm at geeksforgeeks.org`,\r\n      url:\r\n        \"https://www.geeksforgeeks.org/push-relabel-algorithm-set-1-introduction-and-illustration/\"\r\n    },\r\n    {\r\n      label: `Cormen, Leiserson, Rivest, Stein: Introduction to Algorithms (third edition, 2009)`,\r\n      url:\r\n        \"https://openlibrary.org/books/OL25409352M/Introduction_to_Algorithms\"\r\n    }\r\n  ],\r\n  labeledBlocks: [],\r\n  implementation: function*(\r\n    graph: Graph\r\n  ): IterableIterator<{\r\n    highlightedLines?: number[];\r\n    linearNodes: Node[];\r\n    graphMutations?: GraphMutation[];\r\n    done?: true;\r\n  }> {\r\n    const sourceNode = graph.getSourceNode();\r\n\r\n    yield {\r\n      linearNodes: [],\r\n      highlightedLines: [2, 3, 4, 5],\r\n      graphMutations: graph\r\n        .getNodes()\r\n        .map(\r\n          node =>\r\n            new GraphCombinedMutation([\r\n              new GraphNodeHeightMutation(node, 0),\r\n              new GraphNodeExcessMutation(node, 0)\r\n            ])\r\n        )\r\n    };\r\n\r\n    yield {\r\n      linearNodes: [],\r\n      highlightedLines: [6],\r\n      graphMutations: [\r\n        new GraphNodeHeightMutation(sourceNode, graph.getNodes().length),\r\n        new GraphNodeHighlightMutation(sourceNode)\r\n      ]\r\n    };\r\n\r\n    yield {\r\n      linearNodes: [],\r\n      highlightedLines: [7, 8, 9, 10, 11],\r\n      graphMutations: [\r\n        ...sourceNode\r\n          .getOutgoingEdges()\r\n          .map(\r\n            edge =>\r\n              new GraphCombinedMutation([\r\n                new GraphEdgeFlowMutation(edge, edge.getCapacity()),\r\n                new GraphNodeExcessMutation(\r\n                  edge.getTargetNode(),\r\n                  edge.getCapacity()\r\n                ),\r\n                new GraphNodeExcessMutation(sourceNode, -edge.getCapacity()),\r\n                new GraphEdgeHighlightMutation(edge)\r\n              ])\r\n          )\r\n      ]\r\n    };\r\n\r\n    let mutationToUndo = new GraphCombinedMutation([\r\n      new GraphNodeHighlightMutation(sourceNode),\r\n      ...sourceNode\r\n        .getOutgoingEdges()\r\n        .map(edge => new GraphEdgeHighlightMutation(edge))\r\n    ]);\r\n    let finished = false;\r\n    while (!finished) {\r\n      let foundApplicableOperation = false;\r\n      for (const edge of graph.getEdges()) {\r\n        if (pushApplicable(edge)) {\r\n          foundApplicableOperation = true;\r\n          yield {\r\n            linearNodes: [],\r\n            graphMutations: [mutationToUndo.inverse(), push(edge)],\r\n            highlightedLines: [13, 19, 20, 21, 22, 23]\r\n          };\r\n          mutationToUndo = push(edge);\r\n          break;\r\n        }\r\n      }\r\n      if (foundApplicableOperation) continue;\r\n      for (const node of graph.getNodes()) {\r\n        if (relabelApplicable(node)) {\r\n          foundApplicableOperation = true;\r\n          yield {\r\n            linearNodes: [],\r\n            graphMutations: [mutationToUndo.inverse(), relabel(node)],\r\n            highlightedLines: [13, 27]\r\n          };\r\n          mutationToUndo = relabel(node);\r\n          break;\r\n        }\r\n      }\r\n      finished = !foundApplicableOperation;\r\n    }\r\n\r\n    yield {\r\n      linearNodes: [],\r\n      graphMutations: [mutationToUndo.inverse()],\r\n      highlightedLines: [15],\r\n      done: true\r\n    };\r\n  }\r\n};\r\n\r\nconst min = (arr: number[]) =>\r\n  arr.reduce((min, val) => (min < val ? min : val), arr[0]);\r\n\r\nconst pushApplicable = (e: Edge) => {\r\n  const u = e.getSourceNode();\r\n  const v = e.getTargetNode();\r\n  return (\r\n    u.getType() !== \"sink\" &&\r\n    u.getExcess() > 0 &&\r\n    e.getCapacity() > e.getFlow() &&\r\n    u.getHeight() === v.getHeight() + 1\r\n  );\r\n};\r\n\r\nconst push = (e: Edge) => {\r\n  const u = e.getSourceNode();\r\n  const v = e.getTargetNode();\r\n  const df = Math.min(u.getExcess(), e.getCapacity() - e.getFlow());\r\n\r\n  return new GraphCombinedMutation([\r\n    new GraphEdgeFlowMutation(e, df),\r\n    new GraphEdgeHighlightMutation(e),\r\n    new GraphEdgeFlowMutation(e.getReverseEdge(), -df),\r\n    new GraphEdgeHighlightMutation(e.getReverseEdge()),\r\n    new GraphNodeExcessMutation(u, -df),\r\n    new GraphNodeHighlightMutation(u),\r\n    new GraphNodeExcessMutation(v, df),\r\n    new GraphNodeHighlightMutation(v)\r\n  ]);\r\n};\r\n\r\nconst relabelApplicable = (u: Node) =>\r\n  u.getExcess() > 0 &&\r\n  u\r\n    .getOutgoingEdges()\r\n    .filter(e => e.getCapacity() > e.getFlow())\r\n    .every(e => u.getHeight() <= e.getTargetNode().getHeight());\r\n\r\nconst relabel = (u: Node) =>\r\n  new GraphCombinedMutation([\r\n    new GraphNodeHeightMutation(\r\n      u,\r\n      1 +\r\n        min(\r\n          u\r\n            .getOutgoingEdges()\r\n            .filter(e => e.getCapacity() > e.getFlow())\r\n            .map(e => e.getTargetNode().getHeight())\r\n        ) -\r\n        u.getHeight()\r\n    ),\r\n    new GraphNodeHighlightMutation(u)\r\n  ]);\r\n\r\nexport default PushRelabel;\r\n","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","export default function _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}"],"names":["PushRelabel","name","linearDataStructure","pseudocode","sourceName","sinkName","String","raw","references","label","url","labeledBlocks","implementation","graph","sourceNode","getSourceNode","linearNodes","highlightedLines","graphMutations","getNodes","map","node","GraphCombinedMutation","GraphNodeHeightMutation","GraphNodeExcessMutation","length","GraphNodeHighlightMutation","getOutgoingEdges","edge","GraphEdgeFlowMutation","getCapacity","getTargetNode","GraphEdgeHighlightMutation","mutationToUndo","finished","foundApplicableOperation","getEdges","pushApplicable","inverse","push","f","relabelApplicable","relabel","done","e","u","v","getType","getExcess","getFlow","getHeight","df","Math","min","getReverseEdge","filter","every","arr","reduce","val","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","i","F","s","n","value","_e","TypeError","err","normalCompletion","didErr","call","step","next","_e2","_taggedTemplateLiteral","strings","slice","Object","freeze","defineProperties"],"sourceRoot":""}