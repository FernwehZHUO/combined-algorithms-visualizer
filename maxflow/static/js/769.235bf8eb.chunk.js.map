{"version":3,"file":"static/js/769.235bf8eb.chunk.js","mappings":"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","sources":["algorithms/Edmonds-Karp.ts","../node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js"],"sourcesContent":["import {\r\n  Graph,\r\n  GraphMutation,\r\n  Node,\r\n  Edge,\r\n  GraphEdgeFlowMutation,\r\n  GraphNodeHighlightMutation,\r\n  GraphEdgeHighlightMutation\r\n} from \"../CytoscapeGraph\";\r\nimport { Algorithm } from \"../algorithm\";\r\n\r\n/** The Edmonds-Karp algorithm */\r\nconst EdmondsKarp: Algorithm = {\r\n  name: \"Edmonds-Karp\",\r\n  linearDataStructure: \"queue\",\r\n  pseudocode: ({ sourceName, sinkName }) => String.raw`\r\n    \\begin{algorithm}\r\n    \\begin{algorithmic}\r\n    \\PROCEDURE{Edmonds-Karp}{$G=(V,\\ E),\\ ${sourceName} \\in V,\\ ${sinkName} \\in V$}\r\n        \\STATE $f = 0$\r\n        \\REPEAT\r\n            \\STATE $p = \\left[\\ \\right]$\r\n            \\STATE $q = \\left[\\ ${sourceName}\\ \\right]$ \\COMMENT{create queue}\r\n            \\WHILE{$q_\\mathrm{length}$ > 0}\r\n                \\STATE $c =$ \\CALL{dequeue}{$q$}\r\n                \\FOR{edge $e$ originating from $c$}\r\n                    \\IF{$e_\\mathrm{target} \\notin p$ \\AND $e_\\mathrm{target} \\neq ${sourceName}$ \\AND $e_\\mathrm{capacity} > e_\\mathrm{flow}$}\r\n                        \\STATE $p[e_\\mathrm{target}] = e$\r\n                        \\STATE \\CALL{enqueue}{$q$, $e_\\mathrm{target}$}\r\n                    \\ENDIF\r\n                \\ENDFOR\r\n            \\ENDWHILE\r\n            \\IF{$p[${sinkName}] \\neq \\varnothing$}\r\n                \\STATE $\\Delta f = \\infty$\r\n                \\FOR{$e \\in p$}\r\n                    \\STATE $\\Delta f = $ \\CALL{min}{$\\Delta f$, $e_\\mathrm{capacity} - e_\\mathrm{flow}$}\r\n                \\ENDFOR\r\n                \\FOR{$e \\in p$}\r\n                    \\STATE $r = e_\\mathrm{reverse}$\r\n                    \\STATE $e_\\mathrm{flow} = e_\\mathrm{flow} + \\Delta f$\r\n                    \\STATE $r_\\mathrm{flow} = r_\\mathrm{flow} - \\Delta f$\r\n                \\ENDFOR\r\n                \\STATE $f = f + \\Delta f$\r\n            \\ENDIF\r\n        \\UNTIL{$p[${sinkName}] = \\varnothing$}\r\n        \\RETURN $f$\r\n    \\ENDPROCEDURE\r\n    \\end{algorithmic}\r\n    \\end{algorithm}\r\n  `,\r\n  references: [\r\n    {\r\n      label: `Edmonds-Karp Algorithm at Brilliant.org`,\r\n      url: \"https://brilliant.org/wiki/edmonds-karp-algorithm/\"\r\n    },\r\n    {\r\n      label: `Jack Edmonds, Richard M. Karp: Theoretical improvements in algorithmic efficiency for network flow problems (1972)`,\r\n      url:\r\n        \"https://web.eecs.umich.edu/~pettie/matching/Edmonds-Karp-network-flow.pdf\"\r\n    }\r\n  ],\r\n  labeledBlocks: [\r\n    // { lines: [4, 14], label: \"Breadth-first search\" },\r\n    // { lines: [15, 26], label: \"Increase flow along found path\" },\r\n  ],\r\n  implementation: function*(\r\n    graph: Graph\r\n  ): IterableIterator<{\r\n    highlightedLines?: number[];\r\n    linearNodes: Node[];\r\n    graphMutations?: GraphMutation[];\r\n    done?: true;\r\n  }> {\r\n    const sourceNode = graph.getSourceNode();\r\n    const sinkNode = graph.getSinkNode();\r\n\r\n    let flow = 0;\r\n    let pred: { [key: string]: Edge };\r\n\r\n    yield {\r\n      highlightedLines: [4, 5],\r\n      linearNodes: []\r\n    };\r\n\r\n    do {\r\n      const q = [sourceNode];\r\n      pred = {};\r\n\r\n      const mutationsToUndoAfterSearch = [];\r\n\r\n      while (q.length > 0 && !pred[sinkNode.getId()]) {\r\n        yield {\r\n          highlightedLines: [7],\r\n          linearNodes: q,\r\n          graphMutations: []\r\n        };\r\n        const cur = q.shift()!;\r\n        yield {\r\n          highlightedLines: [8],\r\n          linearNodes: q,\r\n          graphMutations: [new GraphNodeHighlightMutation(cur)]\r\n        };\r\n        mutationsToUndoAfterSearch.push(\r\n          new GraphNodeHighlightMutation(cur).inverse()\r\n        );\r\n        for (let edge of cur.getOutgoingEdges()) {\r\n          yield {\r\n            highlightedLines: [9],\r\n            linearNodes: q,\r\n            graphMutations: [new GraphEdgeHighlightMutation(edge)]\r\n          };\r\n          mutationsToUndoAfterSearch.push(\r\n            new GraphEdgeHighlightMutation(edge).inverse()\r\n          );\r\n          if (\r\n            pred[edge.getTargetNode().getId()] === undefined &&\r\n            !edge.getTargetNode().isEqualTo(sourceNode) &&\r\n            edge.getCapacity() > edge.getFlow()\r\n          ) {\r\n            yield {\r\n              highlightedLines: [10, 11],\r\n              linearNodes: q,\r\n              graphMutations: [new GraphEdgeHighlightMutation(edge)]\r\n            };\r\n            mutationsToUndoAfterSearch.push(\r\n              new GraphEdgeHighlightMutation(edge).inverse()\r\n            );\r\n            pred[edge.getTargetNode().getId()] = edge;\r\n            q.push(edge.getTargetNode());\r\n          }\r\n          if (edge.getTargetNode().isEqualTo(sinkNode)) break;\r\n        }\r\n      }\r\n      yield {\r\n        highlightedLines: [15],\r\n        linearNodes: q,\r\n      };\r\n      if (pred[sinkNode.getId()] !== undefined) {\r\n        let currentHighlightEdge = pred[sinkNode.getId()];\r\n        const foundPathHighlightMutations: GraphMutation[] = [];\r\n        while (currentHighlightEdge) {\r\n          foundPathHighlightMutations.push(\r\n            new GraphEdgeHighlightMutation(currentHighlightEdge),\r\n            new GraphNodeHighlightMutation(\r\n              currentHighlightEdge.getSourceNode()\r\n            ),\r\n            new GraphNodeHighlightMutation(currentHighlightEdge.getTargetNode())\r\n          );\r\n          currentHighlightEdge =\r\n            pred[currentHighlightEdge.getSourceNode().getId()];\r\n        }\r\n        const mutationsToUndoAfterUpdate = foundPathHighlightMutations\r\n          .slice()\r\n          .reverse()\r\n          .map(mutation => mutation.inverse());\r\n\r\n        yield {\r\n          highlightedLines: [16],\r\n          linearNodes: q,\r\n          graphMutations: [\r\n            ...mutationsToUndoAfterSearch,\r\n            ...foundPathHighlightMutations\r\n          ]\r\n        };\r\n\r\n        let df = Infinity;\r\n        let currentEdge = pred[sinkNode.getId()];\r\n        let previousEdge = currentEdge;\r\n        while (currentEdge !== undefined) {\r\n          yield {\r\n            highlightedLines: [18],\r\n            linearNodes: q,\r\n            graphMutations: [new GraphEdgeHighlightMutation(previousEdge).inverse(), new GraphEdgeHighlightMutation(currentEdge)]\r\n          }\r\n          df = Math.min(df, currentEdge.getCapacity() - currentEdge.getFlow());\r\n          currentEdge = pred[currentEdge.getSourceNode().getId()];\r\n        }\r\n\r\n        currentEdge = pred[sinkNode.getId()];\r\n        while (currentEdge !== undefined) {\r\n          const reverseCurrentEdge = currentEdge.getReverseEdge();\r\n          yield {\r\n            highlightedLines: [22, 23],\r\n            linearNodes: q,\r\n            graphMutations: [\r\n              new GraphEdgeFlowMutation(currentEdge, df),\r\n              new GraphEdgeFlowMutation(reverseCurrentEdge, -df)\r\n            ]\r\n          };\r\n          currentEdge = pred[currentEdge.getSourceNode().getId()];\r\n        }\r\n        flow = flow + df;\r\n        yield {\r\n          highlightedLines: [25],\r\n          linearNodes: q,\r\n          graphMutations: mutationsToUndoAfterUpdate\r\n        };\r\n      }\r\n    } while (pred[sinkNode.getId()] !== undefined);\r\n    yield {\r\n      highlightedLines: [28],\r\n      linearNodes: [],\r\n      done: true\r\n    };\r\n    return flow;\r\n  }\r\n};\r\n\r\nexport default EdmondsKarp;\r\n","import unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nexport default function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","export default function _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}"],"names":["EdmondsKarp","name","linearDataStructure","pseudocode","sourceName","sinkName","String","raw","references","label","url","labeledBlocks","implementation","graph","sourceNode","getSourceNode","sinkNode","getSinkNode","flow","highlightedLines","linearNodes","q","pred","mutationsToUndoAfterSearch","length","getId","graphMutations","cur","shift","GraphNodeHighlightMutation","push","inverse","getOutgoingEdges","edge","GraphEdgeHighlightMutation","undefined","getTargetNode","isEqualTo","getCapacity","getFlow","f","currentHighlightEdge","foundPathHighlightMutations","mutationsToUndoAfterUpdate","slice","reverse","map","mutation","df","Infinity","currentEdge","previousEdge","Math","min","reverseCurrentEdge","getReverseEdge","GraphEdgeFlowMutation","done","_createForOfIteratorHelper","o","allowArrayLike","it","Symbol","iterator","Array","isArray","i","F","s","n","value","e","_e","TypeError","err","normalCompletion","didErr","call","step","next","_e2","_taggedTemplateLiteral","strings","Object","freeze","defineProperties"],"sourceRoot":""}